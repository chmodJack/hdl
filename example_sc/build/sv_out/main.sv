//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.11
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top_uart_rx ()
//
module top_uart_rx // "top_inst"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic [7:0] data;
logic rx;
logic en;
logic busy;

//------------------------------------------------------------------------------
// Clocked THREAD: run (main.cpp:147:2) 

// Next-state combinational logic
always_comb begin : run_comb     // main.cpp:147:2
    run_func;
end
function void run_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : run_ff
    if ( ~rst ) begin
        rst <= 1;
    end
    else begin
    end
end


//------------------------------------------------------------------------------
// Child module instances

uart_rx ur
(
  .clk(clk),
  .rst(rst),
  .rx(rx),
  .en(en),
  .busy(busy),
  .data(data)
);

endmodule



//==============================================================================
//
// Module: uart_rx (main.cpp:130:2)
//
module uart_rx // "top_inst.ur"
(
    input logic clk,
    input logic rst,
    input logic rx,
    output logic en,
    output logic busy,
    output logic [7:0] data
);

//------------------------------------------------------------------------------
// Clocked THREAD: run (uart_rx.hpp:36:2) 

// Thread-local variables
logic [7:0] buf_v;
logic [7:0] buf_v_next;
logic busy_next;
logic [7:0] data_next;
logic en_next;
logic [3:0] run_PROC_STATE;
logic [3:0] run_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : run_comb     // uart_rx.hpp:36:2
    run_func;
end
function void run_func;
    buf_v_next = buf_v;
    busy_next = busy;
    data_next = data;
    en_next = en;
    run_PROC_STATE_next = run_PROC_STATE;
    
    case (run_PROC_STATE)
        0: begin
            en_next = 0;
            busy_next = 0;
            if (rx == 0)
            begin
                busy_next = 1;
                run_PROC_STATE_next = 1; return;    // uart_rx.hpp:51:5;
            end
            run_PROC_STATE_next = 0; return;    // uart_rx.hpp:44:4;
        end
        1: begin
            buf_v_next[0] = rx;
            run_PROC_STATE_next = 2; return;    // uart_rx.hpp:53:18;
        end
        2: begin
            buf_v_next[1] = rx;
            run_PROC_STATE_next = 3; return;    // uart_rx.hpp:54:18;
        end
        3: begin
            buf_v_next[2] = rx;
            run_PROC_STATE_next = 4; return;    // uart_rx.hpp:55:18;
        end
        4: begin
            buf_v_next[3] = rx;
            run_PROC_STATE_next = 5; return;    // uart_rx.hpp:56:18;
        end
        5: begin
            buf_v_next[4] = rx;
            run_PROC_STATE_next = 6; return;    // uart_rx.hpp:57:18;
        end
        6: begin
            buf_v_next[5] = rx;
            run_PROC_STATE_next = 7; return;    // uart_rx.hpp:58:18;
        end
        7: begin
            buf_v_next[6] = rx;
            run_PROC_STATE_next = 8; return;    // uart_rx.hpp:59:18;
        end
        8: begin
            buf_v_next[7] = rx;
            run_PROC_STATE_next = 9; return;    // uart_rx.hpp:60:18;
        end
        9: begin
            if (rx == 1)
            begin
                en_next = 1;
            end else begin
                en_next = 0;
            end
            busy_next = 0;
            data_next = buf_v_next;
            run_PROC_STATE_next = 0; return;    // uart_rx.hpp:44:4;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : run_ff
    if ( ~rst ) begin
        busy <= 0;
        data <= 0;
        en <= 0;
        run_PROC_STATE <= 0;    // uart_rx.hpp:44:4;
    end
    else begin
        buf_v <= buf_v_next;
        busy <= busy_next;
        data <= data_next;
        en <= en_next;
        run_PROC_STATE <= run_PROC_STATE_next;
    end
end

endmodule


